# 🧠 LEARNING.md — תיעוד תהליך הפיתוח

מסמך זה נכתב כדי לשמש אותי כתיעוד פנימי של כל שלב בפרויקט Tech.Mobility. הוא מתאר את שלבי הבנייה, ההחלטות, זרימת העבודה, חיבורים בין צד הלקוח לשרת, ושיקולים שהובילו למימוש הנוכחי.

---

## 🚀 התחלת הפרויקט

- מטרה: לבנות מערכת מקומית להזמנת נסיעות בזמן אמת (דמו לסביבה קטנה).
- חזון: יישום שמדמה אפליקציות כמו Yango/Wolt אבל בצורה קלה להבנה וניהול.
- טכנולוגיות שנבחרו:
  - **Frontend:** React + Vite
  - **Backend:** Node.js + Express
  - **Database:** MongoDB + Mongoose
  - **Realtime:** Socket.IO
  - **Maps:** Leaflet.js + GraphHopper API

---

## 🧱 מבנה המערכת

### צד לקוח (React)

- `CustomerDashboard.jsx` — לוח לקוח להזמנה, הצגה, ביטול ומעקב אחרי נהגים.
- `DriverDashboard.jsx` — לוח נהג להצגת נסיעות זמינות וקבלה/סירוב.
- `MapView.jsx` — רכיב מפה שמציג:
  - את המיקום שלי
  - איסוף, יעד, נהגים בזמן אמת
  - מסלול מחושב מ-GraphHopper

### צד שרת (Node.js)

- `ridesController.js` — יצירה, קבלה, סירוב, ביטול נסיעות
- `socket.js` — שליחה בזמן אמת של rideUpdate + driverLocation
- `driverController.js` — סטטיסטיקות נהג
- `rideSchema.js` — מבנה של אובייקט נסיעה במסד נתונים

---

## 🔄 זרימת תהליך בין לקוח לשרת

1. לקוח מזין כתובת איסוף ויעד
2. השרת מקבל את הבקשה ב־`/rides` ושולח `rideUpdate` לכל הנהגים
3. נהג רואה את הנסיעה בלוח שלו ולוחץ "אשר"
4. נשלחת בקשה ל־`/rides/:id/accept`
5. השרת מעדכן סטטוס ל־`Accepted` ושולח עדכון בחזרה ללקוח
6. הנהג מתחיל לשדר את המיקום שלו דרך `driverLocationUpdate` ב־socket
7. הלקוח רואה את הנהג מתקרב על המפה

---

## 🗺️ איך עובד ה־MapView

- יוצר את המפה עם Leaflet
- מוסיף סמנים לפי userLocation, pickup, destination
- אם יש גם מיקום נהג — מציג אותו באייקון אחר
- שולח בקשה ל־GraphHopper עם נקודות
- מצייר קו בין הנקודות
- בלחיצה על המפה: מקבל קואורדינטות ומעדכן נקודת איסוף או יעד

---

## 🧪 דגשים לבדיקה

- האם rideUpdate עובד לשני הצדדים (נהג ולקוח)?
- האם driverLocation באמת מתעדכן?
- האם מסלול מוצג רק אם יש גם pickup וגם destination?
- האם נסיעה שלא באחריותי (userId) ניתנת לביטול? (לא אמור לקרות)

---

## 🔐 ולידציה ואבטחת מידע (2025-04-23)

### ✍️ הולידציה והגנה על קלט משתמש:

- שימוש ב־`express-validator` לכל מסלולי התחברות ורישום
- middleware כללי בשם `validateRequestMiddleware`
- עצירת ניסיונות תקיפה כמו:
  - `from: { "$ne": null }`
  - `userId: { "$gt": "" }`

### 🧩 חלקים שנבנו:

- `loginValidator.js` — אימייל + סיסמה
- `registerStepOneValidator.js` — ולידציה מלאה לשלב הראשון של רישום
- `registerStepTwoValidator.js` — ולידציה מלאה ל־Step 2:
  - לקוח: פרטי תשלום + מזהה
  - נהג: פרטי רכב, חשבון בנק, רישיון, שנה, צבע

### ✅ שילוב ברואטים:
- `/login` עם ולידציה
- `/register/:role` עם ולידציה בשלב ראשון
- `/register/:role/step2` עם ולידציה לשלב שני

### 🧪 תוצאה:
- כל שדה נבדק לפי סוג, אורך, תקינות פורמט
- קלטים חשודים (אובייקטים/פקודות) נחסמים
- שגיאות מוחזרות בפורמט ברור עם שמות שדות והודעות מובנות

---

## 🔮 מה הלאה?

- הוספת "טמפיסטים" (נקודות ביניים במסלול)
- ממשק Admin
- הצגת זמני הגעה משוערים
- תמיכה בתשלומים
- התאמה לגרסת מובייל
- הוצאת userId מתוך JWT ולא מה־body
- תיעוד מלא של API בפורמט Swagger

